# Suggested Improvements

## 1. Add request throttling and retry logic around external API fan-out
`discoverCandidateMovies` fires a `Promise.all` over every favorite title and then, for each match, kicks off another pair of `Promise.all` fan-outs to TMDB's recommendations and similar-title endpoints without any concurrency cap or retry/backoff behaviour.【F:assets/js/recommendations.js†L210-L305】 When a user has a long favorites list this results in bursts of 3×N simultaneous requests (search + recommendations + similar) followed by another unbounded `Promise.all` through OMDb and YouTube inside the same recommendation pipeline.【F:assets/js/recommendations.js†L532-L664】【F:assets/js/main.js†L714-L908】 TMDB and OMDb both enforce fairly strict per-second quotas, so a short spike can easily trip 429 responses and leave the UI in the generic error state. Introducing a small semaphore (e.g., limit to 2–3 active requests per API) with exponential backoff retries on 429/5xx responses will make the app much more resilient under real-world usage. Since the module already caches OMDb/YouTube lookups, the throttle can share that cache to skip redundant work.

## 2. Replace the repeated full sort in the scorer with a priority queue
`scoreAndSelectCandidates` currently sorts the entire `remaining` array inside every loop iteration to pick the next title, yielding O(n² log n) behaviour once hundreds of candidates are in play.【F:assets/js/recommendations.js†L487-L520】 The recommendation stage routinely collects dozens of candidates before trimming, so the repeated sorts add noticeable overhead on slower devices. Refactoring this loop to maintain a binary heap (or leveraging a simple sorted insert) would drop the selection step to O(n log n) overall. That keeps the personalization loop snappy even as we raise page sizes or expand the discover/search fan-outs.

## 3. Ship richer HTTP caching and compression from the Node server
The static server always streams files with status 200 and never honours `If-None-Match`/`If-Modified-Since`, does not emit ETag/Last-Modified headers, and serves raw assets without gzip/brotli even though most browsers advertise compression support.【F:server.js†L51-L90】【F:server.js†L111-L158】 As a result, returning visitors re-download large JS/CSS bundles and fonts on every refresh. Layering in conditional GET support (ETag or last-modified checks) and piping responses through `zlib.createGzip`/`createBrotliCompress` for compressible types would dramatically cut payload size and perceived latency, especially on mobile connections. Pair that with a slightly longer `max-age` for hashed asset paths and the app will feel much faster while consuming fewer CDN credits.
